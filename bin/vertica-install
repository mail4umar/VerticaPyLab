#!/bin/bash

# this script sets up a docker container running vertica

# Find the config file
VERTICA_DEMO_PREFIX=$( cd -- "$( dirname -- "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )
VERTICA_DEMO_PREFIX=${VERTICA_DEMO_PREFIX%/bin}
CONFIG_FILE=$VERTICA_DEMO_PREFIX/etc/vertica-demo.conf
if ! [[ -r $CONFIG_FILE ]]; then
  if ! make -C $VERTICA_DEMO_PREFIX etc/vertica-demo.conf >/dev/null || ! [[ -r $CONFIG_FILE ]]; then
    echo "Cannot find config file ($CONFIG_FILE)" >&2
    exit 1
  fi
fi
# Load the configuration
source $CONFIG_FILE

# defaults that can be overridden with environment variables.
: ${VERTICA_PORT:=${VSQL_PORT:-5433}}
: ${VERTICA_SSH_PORT:=5432}
: ${VERTICA_BIND_ADDRESS:=127.0.0.1}
: ${VERTICALAB_CONTAINER_NAME:=verticalab}
: ${VERTICA_CONTAINER_NAME:=vertica-demo}
: ${VERTICA_HOST_NAME:=$VERTICA_CONTAINER_NAME}
: ${DB_NAME:=demo}
: ${VERTICA_DOCKER_IMAGE:=vertica/vertica-k8s:latest} # see https://hub.docker.com/r/vertica/vertica-k8s
: ${DOCKER_NETWORK:=demo}

function abort {
  local retval=$1
  shift
  echo "${BASH_SOURCE##*/}: $@" >&2
  exit $retval
}

# allow for enviornment variables to be
# specified in VERTICA_ENV_FORWARDING
for var in LANG $VERTICA_ENV_FORWARD; do
  if [[ ${!var+isset} ]]; then
    VERTICA_ENV+=(-e "$var=${!var}")
  fi
done

# The OSx version of bash calls the M1 chip "arm64", but if someone updates
# /bin/bash, then it will could use "aarch64" in $MACHTYPE
if [[ $MACHTYPE =~ ^aarch64 ]] || [[ $MACHTYPE =~ ^arm64 ]] ; then
  # Arm based macs crash on a memory check unless this is added
  VERTICA_ENV+=(-e VERTICA_MEMDEBUG=2)
  VERTICA_RUNARGS+=( --platform linux/amd64 )
fi

if [[ -n $DOCKER_HOST ]] && [[ $VERTICA_BIND_ADDRESS == 127.0.0.1 ]]; then
  # Try to support docker-machine networking
  VERTICA_BIND_ADDRESS=${DOCKER_HOST##tcp://}
  VERTICA_BIND_ADDRESS=${VERTICA_BIND_ADDRESS%%:*}
fi

VERTICA_RUNARGS+=( -p "$VERTICA_BIND_ADDRESS:$VERTICA_PORT:5433" )
VERTICA_RUNARGS+=( -p "$VERTICA_BIND_ADDRESS:$((VERTICA_PORT+11)):5444" )
VERTICA_RUNARGS+=( -p "$VERTICA_BIND_ADDRESS:$VERTICA_SSH_PORT:22" )
VERTICA_RUNARGS+=( --rm )
VERTICA_RUNARGS+=( --name "$VERTICA_CONTAINER_NAME" )
VERTICA_RUNARGS+=( --hostname "$VERTICA_HOST_NAME" )

# mount the home directory unless the user is dbadmin because this docker
# requires files from /home/dbadmin
if [[ $HOME != dbadmin ]] ; then
  VERTICA_RUNARGS+=( --mount "type=bind,source=$HOME,target=$HOME" )
fi

# Use a network just for this demo
docker network create "$DOCKER_NETWORK" 2>/dev/null
VERTICA_RUNARGS+=( --network "$DOCKER_NETWORK" )

# clear out old container in case it had issues
docker container rm $VERTICA_CONTAINER_NAME 2>/dev/null

docker run --detach "${VERTICA_RUNARGS[@]}" "${VERTICA_ENV[@]}" "$VERTICA_DOCKER_IMAGE" || abort $? "Could not create docker"

# SSHD tweaks
# don't use DNS in sshd because it slows down ssh
# (this seems to execute before sshd starts, so the SIGHUP may not be needed)
docker exec -i "${VERTICA_ENV[@]}" $VERTICA_CONTAINER_NAME bash -c 'sudo sed -i "s/^#UseDNS yes/UseDNS no/" /etc/ssh/sshd_config; sudo kill -1 $(/bin/pgrep -x sshd) 2>/dev/null'

# this allows ssh commands to succeed with the default LANG in the image
# (this locale.alias file is deprecated)
docker exec -i "${VERTICA_ENV[@]}" $VERTICA_CONTAINER_NAME sudo bash -c 'echo "C.UTF-8         en_US.UTF-8" >> /usr/share/locale/locale.alias'

# regenerate the ssh key for security
echo y | docker exec -i "${VERTICA_ENV[@]}" $VERTICA_CONTAINER_NAME ssh-keygen -t rsa -f /home/dbadmin/.ssh/id_rsa -N '' -C vertica-demo -q >/dev/null
docker exec -i "${VERTICA_ENV[@]}" $VERTICA_CONTAINER_NAME bash -c "cat /home/dbadmin/.ssh/id_rsa.pub > /home/dbadmin/.ssh/authorized_keys; rm /home/dbadmin/.ssh/authorized_keys2"

# if verticalab is running, make sure it can connect to vertica-demo
if docker exec -i "$VERTICALAB_CONTAINER_NAME" true 2>/dev/null; then
  # copy dbadmin@vertica-demo credentials to root@verticapy-demo to enable ssh
  docker exec -i "$VERTICA_CONTAINER_NAME" bash -c "cd; tar -zcf - .ssh" | docker exec -i "$VERTICALAB_CONTAINER_NAME" bash -c "cd; tar -zxf -"
  # add the ip address of vertica-demo to /etc/hosts
  HOSTS_START=$(docker exec -i "$VERTICALAB_CONTAINER_NAME" grep -v vertica-demo /etc/hosts)
  if HOSTS_ADD=$(docker network inspect -f '{{range .Containers}}{{if (eq .Name "'"$VERTICA_CONTAINER_NAME"'")}}{{index (split .IPv4Address "/") 0}}        {{.Name}}{{println}}{{end}}{{end}}' "$DOCKER_NETWORK"); then 
    if [[ $VERTICA_CONTAINER_NAME != vertica-demo ]] ; then
      # so vertica-demo works no matter what you call your demo container
      HOSTS_ADD=$(echo "$HOSTS_ADD" | sed "s/$VERTICA_CONTAINER_NAME/$VERTICA_CONTAINER_NAME vertica-demo/")
    fi
    printf "%s\n" "$HOSTS_START" "$HOSTS_ADD" | docker exec -i "$VERTICALAB_CONTAINER_NAME" tee /etc/hosts > /dev/null
  fi
fi

# user in container should match the home directory
if [[ $OSTYPE == darwin* ]]; then # OSX uses different args for stat
  : ${LOGNAME:=$(stat -f "%Su" "$HOME")} # if LOGNAME is not set, use the owner of the home directory
  : ${LOGGROUP:=$(stat -f "%Sg" "$HOME")}
else
  : ${LOGNAME:=$(stat -c "%U" "$HOME")} # if LOGNAME is not set, use the owner of the home directory
  : ${LOGGROUP:=$(stat -c "%G" "$HOME")}
fi

# determine uid/gid of mounted home directory (in case docker maps to a different id)
: ${USERID:=$(docker exec -i "${VERTICA_ENV[@]}" $VERTICA_CONTAINER_NAME stat -c "%u:%g" "$HOME")}

# If the home directory mount is owned by non-root, make it look like it's
# owned by the actual owner by creating an account within the container.
if [[ $USERID =~ ^[1-9][0-9]*: ]] ; then
  # does host's user exist in docker?  (i.e., dbadmin, ftp, root)
  if ! docker exec -i -u $LOGNAME "${VERTICA_ENV[@]}" $VERTICA_CONTAINER_NAME sudo true >/dev/null 2>&1; then
    # add group if we need to and its safe
    if [[ $LOGGROUP != $(docker exec -i "${VERTICA_ENV[@]}" $VERTICA_CONTAINER_NAME stat -c "%G" "$HOME") ]] && [[ ${USERID#*:} -ge 20 ]] ; then
      # it's optional but nice to see group names correct on files, but don't
      # touch group names in /etc/passwd that are <20.  However, 14 is
      # available, so renumber whatever has ${USERID#*:} to 14 and then add the group
      docker exec -i "${VERTICA_ENV[@]}" $VERTICA_CONTAINER_NAME bash -c 'sudo groupmod -g 14 $(getent group "'"${USERID#*:}"'" | cut -d: -f1) 2>/dev/null' # change gid of group
    fi
    docker exec -i "${VERTICA_ENV[@]}" $VERTICA_CONTAINER_NAME sudo groupadd --gid "${USERID#*:}" "$LOGGROUP"

    # make a host user to match home directory ownership
    docker exec -i "${VERTICA_ENV[@]}" $VERTICA_CONTAINER_NAME sudo useradd --uid "${USERID%%:*}" --gid "${USERID#*:}" --home-dir "$HOME" --no-create-home "$LOGNAME" || abort $? "Could not create user $LOGNAME ($USERID)"
  fi

  # add user to sudoers
  docker exec -i "${VERTICA_ENV[@]}" $VERTICA_CONTAINER_NAME sudo bash -c "echo '$LOGNAME ALL=(ALL) NOPASSWD: ALL' >> /etc/sudoers" || abort $? "Could not give $LOGNAME sudo access"
fi

# a temporary fix to allow restarts of the docker container
docker exec -i "${VERTICA_ENV[@]}" $VERTICA_CONTAINER_NAME sed -i.bak 's/\(cp.*\)/\1 || true/' /opt/vertica/bin/docker-entrypoint.sh

# is the EULA signed?
if [[ -z $VERTICA_EULA ]]; then
  docker exec -i "${VERTICA_ENV[@]}" "$VERTICA_CONTAINER_NAME" rm -f /opt/vertica/config/d5415f948449e9d4c421b568f2411140.dat
  if tty >/dev/null; then
    TTY=-t;
  fi
fi

# create the database
docker exec -i $TTY "${VERTICA_ENV[@]}" "$VERTICA_CONTAINER_NAME" opt/vertica/bin/admintools -t create_db --database="$DB_NAME" --password= --hosts=localhost || exit $?

# record the EULA sign date so we don't need to sign again
if [[ -z $VERTICA_EULA ]] && docker exec -i "${VERTICA_ENV[@]}" "$VERTICA_CONTAINER_NAME" test -r /opt/vertica/config/d5415f948449e9d4c421b568f2411140.dat; then
  echo "VERTICA_EULA=$(date +%s)" >> $CONFIG_FILE
fi
